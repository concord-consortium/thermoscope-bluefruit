/*
 * Need to figure out the licensing of the Adafruit code.
It says MIT but then it adds conditions: like including all of the text above and the splash screen.
The thermistor code was taking from the Adafruit learn page.
The bluetooth code was copied from their healththermometer example.
 */

#include <Arduino.h>
#include <SPI.h>
#if not defined (_VARIANT_ARDUINO_DUE_X_) && not defined (_VARIANT_ARDUINO_ZERO_)
  #include <SoftwareSerial.h>
#endif

#include "Adafruit_BLE.h"
#include "Adafruit_BluefruitLE_SPI.h"
#include "Adafruit_BluefruitLE_UART.h"
#include "Adafruit_BLEGatt.h"
#include "Adafruit_BLEBattery.h"

#include "BluefruitConfig.h"

// which analog pin to connect
#define THERMISTORPIN A2         
// resistance at 25 degrees C
#define THERMISTORNOMINAL 10000      
// temp. for nominal resistance (almost always 25 C)
#define TEMPERATURENOMINAL 25   
// how many samples to take and average, more takes longer
// but is more 'smooth'
#define NUMSAMPLES 80
// The beta coefficient of the thermistor (usually 3000-4000)
#define BCOEFFICIENT 3950
// the value of the 'other' resistor
#define SERIESRESISTOR 10000    

// Battery pin
#define VBATPIN A7
      
int samples[NUMSAMPLES];

/* Create the bluefruit object, if you want to use this sketch with a different bluefruit
 *  module configuration see the bluefruit examples for the different configurations.
 *  This is specific to the bluefruit feather:
 *  hardware SPI, using SCK/MOSI/MISO hardware SPI pins and then user selected CS/IRQ/RST 
 */
Adafruit_BluefruitLE_SPI ble(BLUEFRUIT_SPI_CS, BLUEFRUIT_SPI_IRQ, BLUEFRUIT_SPI_RST);

// Setup the gatt object
Adafruit_BLEGatt gatt(ble);

// Setup battery object
Adafruit_BLEBattery battery(ble);

// A small helper
void error(const __FlashStringHelper*err) {
  Serial.println(err);
  while (1);
}

/* The service information */

int32_t tsServiceIdA;
int32_t tsMeasureCharIdA;

uint32_t disconnectedCount;

void setup(void) {
  // Not sure if this is needed or not
  delay(500);

  Serial.begin(115200);
  // would be good to have a version string here that was also published through gatt
  Serial.println(F("Bluefruit Thermoscope"));
  Serial.println(F("--------------------------------------------"));

  if ( !ble.begin(VERBOSE_MODE) )
  {
    error(F("Couldn't find Bluefruit, make sure it's in CoMmanD mode & check wiring?"));
  }
  Serial.println( F("OK!") );

  /* Perform a factory reset to make sure everything is in a known state */
  Serial.println(F("Performing a factory reset: "));
  if (! ble.factoryReset() ){
       error(F("Couldn't factory reset"));
  }

  /* Disable command echo from Bluefruit */
  ble.echo(false);

  Serial.println("Requesting Bluefruit info:");
  /* Print Bluefruit information */
  ble.info();

  /* Change the device name to make it easier to find */
  Serial.println(F("Setting device name to 'Thermoscope': "));

  if (! ble.sendCommandCheckOK(F("AT+GAPDEVNAME=Thermoscope")) ) {
    error(F("Could not set device name?"));
  }

  /* Service ID should be 1 */
  // TODO see if we avoid this duplicate UUID def to prevent a mistake
  // The a normal uuid was generated and then the 3 and 4 bytes were 00'd out
  Serial.println(F("Adding the Thermoscope Sensor A Service bc440000-f244-4f49-b656-df49857755e4:"));
  //  uint8_t sensorAServiceUUID[] = 
  //  {0xbc, 0x44, 0x00, 0x00, 0xf2, 0x44, 0x4f, 0x49, 0xb6, 0x56, 0xdf, 0x49, 0x85, 0x77, 0x55, 0xe4 };
  // TODO: Using sensor tag vendor id since the autogenerated one above didn't work????
  uint8_t sensorAServiceUUID[] = 
    {0xf0, 0x00, 0xaa, 0x00, 0x04, 0x51, 0x40, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
  tsServiceIdA = gatt.addService(sensorAServiceUUID);
  if (tsServiceIdA == 0) {
    error(F("Could not add service"));
  }
  
  /* Add the Temperature Measurement characteristic which is composed of
   * 1 byte flags + 4 float */
  /* Chars ID for Measurement should be 1 */
  // TODO we can probably use a standard Temperature characteristic for this 
  Serial.println(F("Adding the Temperature Measurement characteristic (UUID = 0x0001):"));
  // We are going to try sending the temperatue as a 2byte 16bit integer with a exponent of -2
  // so a temperatue of 30.01 which will be sent as 3001
  tsMeasureCharIdA = gatt.addCharacteristic(
    0x0001, // UUID
    GATT_CHARS_PROPERTIES_READ | GATT_CHARS_PROPERTIES_NOTIFY, // read and notify
    4, // min len
    4, // max len
    BLE_DATATYPE_BYTEARRAY); // tried using integer here but underlying gatt library always 
                             // uses bytearray which then caused an error when calling writeChar

  if (tsMeasureCharIdA == 0) {
    error(F("Could not add characteristic"));
  }

  // Switch to 12 bit resolution
  analogReadResolution(12);

  // Enable Battery service do not reset, we'll do that ourselves
  battery.begin(false);
  
  /* Reset the device for the new service setting changes to take effect */
  Serial.print(F("Performing a SW reset (service changes require a reset): "));
  ble.reset();

  Serial.println();

  disconnectedCount = 0;
}
 
void loop(void) {
  uint8_t i;
  float average;

  if(!ble.isConnected()){
    disconnectedCount += 1;
    Serial.print("No connection. Count: ");
    Serial.println(disconnectedCount);
    if(disconnectedCount > 60){
      // Serial.println("No connection before timeout, should shutdown here");

      // Seems the best option I can find is using rtc standby:
      // https://github.com/cavemoa/Feather-M0-Adalogger/blob/master/SimpleSleepUSB/SimpleSleepUSB.ino
      // send it to sleep so the reset button will wake it up
      // However it might be fine to not sleep and just check for a connection ever so often.
      // It depends on how power hungry the dely is 
      // set_sleep_mode(SLEEP_MODE_PWR_DOWN);
      // sleep_enable();
      // sleep_mode();
    }
    delay(2000);
    // do not do any analog collection until we are connected
    return;
  }

  // if we are here then we are connected
  disconnectedCount = 0;
 
  // Update battery reading
  float measuredvbat = analogRead(VBATPIN);
  measuredvbat *= 2;    // we divided by 2, so multiply back
  measuredvbat *= 3.3;  // Multiply by 3.3V, our reference voltage
  measuredvbat /= 4096; // convert to voltage in 12bit mode
  // the voltage should range between 3 and 4.2 (but might go higher)
  uint8_t percentage = (uint8_t)((measuredvbat - 3.0) / 1.25 * 100);
  
  Serial.print("Update battery level voltage: ");
  Serial.print(measuredvbat);
  Serial.print(" percent: ");
  Serial.println(percentage);  
  battery.update(percentage);

  
  // take N samples in a row, with a slight delay
  for (i=0; i< NUMSAMPLES; i++) {
   samples[i] = analogRead(THERMISTORPIN);
   // delay(1);
  }
 
  // average all the samples out
  average = 0;
  for (i=0; i< NUMSAMPLES; i++) {
     average += samples[i];
  }
  average /= NUMSAMPLES;
 
  // Serial.print("Average analog reading "); 
  // Serial.println(average);
 
  // convert the value to resistance
  average = 4095 / average - 1;
  average = SERIESRESISTOR / average;
  // Serial.print("Thermistor resistance "); 
  // Serial.println(average);
 
  float steinhart;
  steinhart = average / THERMISTORNOMINAL;     // (R/Ro)
  steinhart = log(steinhart);                  // ln(R/Ro)
  steinhart /= BCOEFFICIENT;                   // 1/B * ln(R/Ro)
  steinhart += 1.0 / (TEMPERATURENOMINAL + 273.15); // + (1/To)
  steinhart = 1.0 / steinhart;                 // Invert
  steinhart -= 273.15;                         // convert to C
 
  Serial.print("Temperature "); 
  Serial.print(steinhart);
  Serial.println(" *C");

  // convert temperature to 32bit integer with 2 decimals of precision
  // need to verify that negative numbers work
  int32_t temperature_100 = (int32_t)(steinhart * 100);
  Serial.print("Temperature*100 "); 
  Serial.println(temperature_100);
  
  gatt.setChar(tsMeasureCharIdA, (int32_t)(steinhart * 100));
 
  delay(500);
}
